import uuid
from pathlib import Path
from typing import List, Optional
from datetime import datetime

from ebooklib import epub

from pipeline.common_structure.schemas import (
    CommonStructureOutput,
    StructureEntry,
    PageReference,
    BookMetadata
)
from .content_extractor import ChapterContent


def build_epub(
    output_path: Path,
    structure: CommonStructureOutput,
    chapters: List[ChapterContent],
    logger,
    generate_page_list: bool = True,
    css_theme: str = "serif"
) -> epub.EpubBook:
    book = epub.EpubBook()

    _add_metadata(book, structure.metadata)

    css = _get_css_for_theme(css_theme)
    nav_css = epub.EpubItem(
        uid="style_nav",
        file_name="style/nav.css",
        media_type="text/css",
        content=css
    )
    book.add_item(nav_css)

    epub_chapters = []
    toc_entries = []

    for chapter in chapters:
        epub_chapter = _create_chapter_xhtml(chapter, nav_css)
        book.add_item(epub_chapter)
        epub_chapters.append(epub_chapter)

        toc_entries.append(epub_chapter)

    toc = _build_hierarchical_toc(structure.entries, epub_chapters, chapters)
    book.toc = toc

    book.spine = ["nav"] + epub_chapters

    book.add_item(epub.EpubNcx())
    book.add_item(epub.EpubNav())

    logger.info(f"Writing ePub to {output_path}...")
    epub.write_epub(str(output_path), book)

    logger.info(f"âœ“ ePub generated: {output_path}")
    return book


def _add_metadata(book: epub.EpubBook, metadata: BookMetadata):
    book.set_identifier(metadata.scan_id)
    book.set_title(metadata.title or "Untitled")
    book.set_language(metadata.language)

    if metadata.author:
        book.add_author(metadata.author)

    if metadata.publisher:
        book.add_metadata("DC", "publisher", metadata.publisher)

    if metadata.publication_year:
        book.add_metadata("DC", "date", str(metadata.publication_year))

    book.add_metadata(
        "DC",
        "description",
        f"Generated by Scanshelf from scan {metadata.scan_id}"
    )
    book.add_metadata("DC", "contributor", "Scanshelf Pipeline")


def _get_css_for_theme(theme: str) -> str:
    if theme == "sans-serif":
        font_family = "Arial, Helvetica, sans-serif"
    elif theme == "custom":
        font_family = "Georgia, serif"
    else:
        font_family = "Georgia, 'Times New Roman', serif"

    return f"""
@namespace epub "http://www.idpf.org/2007/ops";

body {{
    font-family: {font_family};
    font-size: 1em;
    line-height: 1.6;
    margin: 1em;
}}

h1 {{
    font-size: 2em;
    margin-top: 1em;
    margin-bottom: 0.5em;
    text-align: center;
}}

h2 {{
    font-size: 1.5em;
    margin-top: 0.8em;
    margin-bottom: 0.4em;
}}

h3 {{
    font-size: 1.2em;
    margin-top: 0.6em;
    margin-bottom: 0.3em;
}}

p {{
    margin: 0.5em 0;
    text-indent: 1.5em;
}}

p.no-indent {{
    text-indent: 0;
}}

.footnotes {{
    margin-top: 2em;
    padding-top: 1em;
    border-top: 1px solid #ccc;
    font-size: 0.9em;
}}

.footnote {{
    margin-bottom: 0.5em;
}}

.footnote-ref {{
    vertical-align: super;
    font-size: 0.8em;
}}

.page-break {{
    margin: 0 0.5em;
    color: #999;
    font-size: 0.8em;
}}

span[epub|type~="pagebreak"] {{
    display: inline;
    color: #999;
}}
"""


def _create_chapter_xhtml(chapter: ChapterContent, css: epub.EpubItem) -> epub.EpubHtml:
    filename = f"chapter_{chapter.entry_id}.xhtml"

    html_parts = []

    heading_level = min(chapter.level + 1, 6)
    html_parts.append(f"<h{heading_level}>{_escape_html(chapter.title)}</h{heading_level}>")

    paragraphs = chapter.body_text.split("\n\n")
    for i, para in enumerate(paragraphs):
        if not para.strip():
            continue
        class_attr = ' class="no-indent"' if i == 0 else ''
        html_parts.append(f"<p{class_attr}>{_escape_html(para)}</p>")

    if chapter.footnotes:
        html_parts.append('<div class="footnotes">')
        html_parts.append('<h3>Notes</h3>')
        for fn in chapter.footnotes:
            html_parts.append(
                f'<div class="footnote" id="fn{fn.number}">'
                f'<sup>{fn.number}</sup> {_escape_html(fn.text)}'
                f'</div>'
            )
        html_parts.append('</div>')

    content = "\n".join(html_parts)

    epub_chapter = epub.EpubHtml(
        title=chapter.title,
        file_name=filename,
        lang="en"
    )
    epub_chapter.content = content
    epub_chapter.add_item(css)

    return epub_chapter


def _build_hierarchical_toc(
    entries: List[StructureEntry],
    epub_chapters: List[epub.EpubHtml],
    chapter_contents: List[ChapterContent]
) -> List:
    id_to_epub = {
        content.entry_id: epub_ch
        for content, epub_ch in zip(chapter_contents, epub_chapters)
    }

    toc = []

    for entry in entries:
        if entry.entry_id in id_to_epub:
            toc.append(id_to_epub[entry.entry_id])

    return toc


def _escape_html(text: str) -> str:
    return (
        text.replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
        .replace("'", "&#39;")
    )
