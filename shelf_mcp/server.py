#!/usr/bin/env python3
"""MCP server for Shelf book library.

Exposes processed book content to Claude for Q&A, summarization, and research.

Run with:
    uv run python shelf_mcp/server.py

Add to Claude Code:
    claude mcp add --transport stdio shelf-books -- uv run python shelf_mcp/server.py
"""

import sys
from pathlib import Path
from typing import Optional

from fastmcp import FastMCP

# Add project root to path for imports
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from shelf_mcp.tools.library import list_books, get_book_info
from shelf_mcp.tools.content import get_toc, get_chapter, get_chapter_metadata, summarize_chapter
from shelf_mcp.tools.search import search_book, search_library
from shelf_mcp.resources.book_resources import get_book_metadata, get_book_toc, get_chapter_content

# Initialize FastMCP server
mcp = FastMCP(
    "Shelf Books",
    instructions="Access your processed book library. Query books, read chapters, and search content.",
)


# ============================================================================
# TOOLS - Library Management
# ============================================================================


@mcp.tool
def tool_list_books() -> dict:
    """List all books in your library with completed processing.

    Returns a list of books with scan_id, title, author, and chapter counts.
    Use this to discover what books are available for querying.
    """
    return list_books()


@mcp.tool
def tool_get_book_info(scan_id: str) -> dict:
    """Get detailed information about a specific book.

    Args:
        scan_id: The book identifier (e.g., "admirals", "roosevelt-autobiography").

    Returns detailed metadata including title, author, chapter count,
    page count, and processing statistics.
    """
    return get_book_info(scan_id)


# ============================================================================
# TOOLS - Content Access
# ============================================================================


@mcp.tool
def tool_get_toc(scan_id: str) -> dict:
    """Get the table of contents for a book.

    Args:
        scan_id: The book identifier.

    Returns the hierarchical structure of the book with entry IDs, titles,
    levels, and word counts. Use entry_ids with get_chapter() to retrieve text.
    """
    return get_toc(scan_id)


@mcp.tool
def tool_get_chapter(
    scan_id: str,
    entry_id: Optional[str] = None,
    title_search: Optional[str] = None,
    chunk_size: int = 0,
    chunk_number: int = 1,
    overlap: int = 0,
) -> dict:
    """Get the text of a chapter or section, optionally in chunks.

    Args:
        scan_id: The book identifier.
        entry_id: The entry ID (e.g., "ch_006", "part_001"). Use get_toc() to find IDs.
        title_search: Alternative: search by title (case-insensitive partial match).
        chunk_size: Characters per chunk. 0 = full text (default). Use 8000 for ~2000 tokens.
        chunk_number: Which chunk to return (1-indexed). Default: 1.
        overlap: Characters to overlap between chunks (default: 0). Use 200 to preserve context.

    Returns the chapter's text with metadata and chunking info.
    For large chapters, use chunk_size=8000, overlap=200 and iterate through chunk_number.
    """
    return get_chapter(scan_id, entry_id, title_search, chunk_size, chunk_number, overlap)


@mcp.tool
def tool_get_chapter_metadata(scan_id: str, entry_id: str) -> dict:
    """Get chapter metadata without full text (quick overview).

    Args:
        scan_id: The book identifier.
        entry_id: The entry ID (e.g., "ch_006", "part_001").

    Returns metadata including word count, character count, page range,
    and recommended_chunks for planning chunked reads.
    """
    return get_chapter_metadata(scan_id, entry_id)


@mcp.tool
def tool_summarize_chapter(scan_id: str, entry_id: str, max_words: int = 500) -> dict:
    """Generate an LLM-powered summary of a chapter.

    Args:
        scan_id: The book identifier.
        entry_id: The entry ID (e.g., "ch_006", "part_001").
        max_words: Target summary length (default: 500 words).

    Returns a ~500 word summary generated by LLM.
    Note: This incurs API costs via OpenRouter (~$0.001-0.01 per chapter).
    """
    return summarize_chapter(scan_id, entry_id, max_words)


# ============================================================================
# TOOLS - Search
# ============================================================================


@mcp.tool
def tool_search_book(
    scan_id: str,
    query: str,
    case_sensitive: bool = False,
    limit: int = 10,
    offset: int = 0,
    snippets_per_entry: int = 3,
) -> dict:
    """Search for text within a specific book with pagination.

    Args:
        scan_id: The book identifier.
        query: Text to search for (minimum 2 characters).
        case_sensitive: Whether to match case (default: False).
        limit: Max entries to return (default: 10).
        offset: Entries to skip for pagination (default: 0).
        snippets_per_entry: Max context snippets per entry (default: 3).

    Returns matching entries with snippets. Check pagination.has_more
    and use pagination.next_offset to get more results.
    """
    return search_book(scan_id, query, case_sensitive, limit, offset, snippets_per_entry)


@mcp.tool
def tool_search_library(
    query: str,
    case_sensitive: bool = False,
    limit_per_book: int = 5,
    offset: int = 0,
    limit_books: int = 10,
    snippets_per_entry: int = 2,
) -> dict:
    """Search for text across all books in your library with pagination.

    Args:
        query: Text to search for (minimum 2 characters).
        case_sensitive: Whether to match case (default: False).
        limit_per_book: Max entries per book (default: 5).
        offset: Books to skip for pagination (default: 0).
        limit_books: Max books to return (default: 10).
        snippets_per_entry: Max snippets per entry (default: 2).

    Returns matching entries from all books. Check pagination.has_more
    and use pagination.next_offset to paginate through books with matches.
    """
    return search_library(query, case_sensitive, limit_per_book, offset, limit_books, snippets_per_entry)


# ============================================================================
# RESOURCES - URI-based Access
# ============================================================================


@mcp.resource("book://{scan_id}/metadata")
def resource_metadata(scan_id: str) -> str:
    """Get book metadata as JSON.

    URI pattern: book://{scan_id}/metadata
    Example: book://admirals/metadata
    """
    return get_book_metadata(scan_id)


@mcp.resource("book://{scan_id}/toc")
def resource_toc(scan_id: str) -> str:
    """Get book table of contents as JSON.

    URI pattern: book://{scan_id}/toc
    Example: book://admirals/toc
    """
    return get_book_toc(scan_id)


@mcp.resource("book://{scan_id}/chapter/{entry_id}")
def resource_chapter(scan_id: str, entry_id: str) -> str:
    """Get chapter content as plain text.

    URI pattern: book://{scan_id}/chapter/{entry_id}
    Example: book://admirals/chapter/ch_006
    """
    return get_chapter_content(scan_id, entry_id)


# ============================================================================
# Entry Point
# ============================================================================


if __name__ == "__main__":
    mcp.run()
